# 3.3 çº¿æ€§å›å½’çš„ç®€æ´å®ç°
ä½¿ç”¨æ·±åº¦å­¦ä¹ æ¡†æ¶ç®€æ´å®ç°ä¸Šä¸€èŠ‚ä¸­çš„çº¿æ€§å›å½’æ¨¡å‹


```python
!pip install -U d2l
!python -m pip install paddlepaddle -i https://mirror.baidu.com/pypi/simple
```


```python
import random
import numpy as np
# torch
import torch
from d2l import torch as d2l
from torch.utils import data
# paddle
import paddle
import matplotlib.pyplot as plt
```


```python
def synthetic_data(w, b, num_examples):
  """Generate y = Xw + b + noise."""
  X = np.random.normal(0, 1, (num_examples, len(w)))
  y = np.dot(X, w) + b
  y += np.random.normal(0, 0.01, y.shape)
  X = paddle.to_tensor(X)
  y = paddle.to_tensor(y)
  return X, y.reshape((-1, 1))
```

## 3.3.1 ç”Ÿæˆæ•°æ®é›†
### torchç‰ˆ


```python
torch_w = torch.tensor([2, -3.4])
torch_b = 4.2
torch_features, torch_labels = d2l.synthetic_data(torch_w, torch_b, 1000)
```


```python
print(torch_features.shape, torch_labels.shape)
```

### paddleç‰ˆ


```python
paddle_w = paddle.to_tensor([2,-3.4])
paddle_b = 4.2
paddle_features, paddle_labels = synthetic_data(paddle_w, paddle_b, 1000)
```


```python
print(paddle_features.shape, paddle_labels.shape)
```

## 3.3.2 è¯»å–æ•°æ®é›†
å¯ä»¥è°ƒç”¨æ¡†æ¶ä¸­ç°æœ‰çš„APIæ¥è¯»å–æ•°æ®ã€‚æˆ‘ä»¬å°†featureså’Œlabelsä½œä¸ºAPIçš„å‚æ•°ä¼ é€’ï¼Œå¹¶åœ¨å®ä¾‹åŒ–æ•°æ®è¿­ä»£å™¨å¯¹è±¡æ—¶æŒ‡å®šbatch_sizeã€‚æ­¤å¤–ï¼Œå¸ƒå°”å€¼is_trainè¡¨ç¤ºæ˜¯å¦å¸Œæœ›æ•°æ®è¿­ä»£å™¨å¯¹è±¡åœ¨æ¯ä¸ªè¿­ä»£å‘¨æœŸå†…æ‰“ä¹±æ•°æ®ã€‚

### torchç‰ˆ


```python
def torch_load_array(data_arrays, batch_size, is_train=True):
    """æ„é€ ä¸€ä¸ªPyTorchæ•°æ®è¿­ä»£å™¨ã€‚"""
    # print(len(data_arrays))
    dataset = data.TensorDataset(*data_arrays)
    return data.DataLoader(dataset, batch_size, shuffle=is_train)

torch_batch_size = 10
torch_data_iter = torch_load_array((torch_features, torch_labels), torch_batch_size)
```

ä½¿ç”¨data_iterçš„æ–¹å¼ä¸æˆ‘ä»¬åœ¨ 3.2èŠ‚ä¸­ä½¿ç”¨data_iterå‡½æ•°çš„æ–¹å¼ç›¸åŒã€‚ä¸ºäº†éªŒè¯æ˜¯å¦æ­£å¸¸å·¥ä½œï¼Œè®©æˆ‘ä»¬è¯»å–å¹¶æ‰“å°ç¬¬ä¸€ä¸ªå°æ‰¹é‡æ ·æœ¬ã€‚ ä¸ 3.2èŠ‚ä¸åŒï¼Œè¿™é‡Œæˆ‘ä»¬ä½¿ç”¨iteræ„é€ Pythonè¿­ä»£å™¨ï¼Œå¹¶ä½¿ç”¨nextä»è¿­ä»£å™¨ä¸­è·å–ç¬¬ä¸€é¡¹ã€‚


```python
# print(type(torch_data_iter))
next(iter(torch_data_iter))
```

### paddleç‰ˆ


```python
# æµ‹è¯•TensorDataset
from paddle.io import TensorDataset
input_np = np.random.random([2, 3, 4]).astype('float32')
input = paddle.to_tensor(input_np)
label_np = np.random.random([2, 1]).astype('int32')
label = paddle.to_tensor(label_np)

dataset = TensorDataset([input, label])
print(len(dataset))
loader = DataLoader(dataset, 10, shuffle=True)

def test_load_array(data_arrays, batch_size, is_train=True):
    """æ„é€ ä¸€ä¸ªPyTorchæ•°æ®è¿­ä»£å™¨ã€‚"""
    print(len(data_arrays))
    dataset = TensorDataset(data_arrays)
    return DataLoader(dataset, batch_size, shuffle=is_train)

test_batch_size = 10
test_data_iter = test_load_array((input, label), test_batch_size)
```


```python
from paddle.io import TensorDataset, DataLoader
def paddle_load_array(data_arrays, batch_size, is_train=True):
    """æ„é€ ä¸€ä¸ªpaddleæ•°æ®è¿­ä»£å™¨ã€‚"""
    print(len(data_arrays))
    dataset = TensorDataset(data_arrays)
    return DataLoader(dataset, batch_size, shuffle=is_train)

paddle_batch_size = 10
paddle_data_iter = paddle_load_array((paddle_features, paddle_labels), paddle_batch_size)
```


```python
print(type(paddle_data_iter))
for X, y in paddle_data_iter:
  print(X, y)
# next(iter(paddle_data_iter))
```

## 3.3.3 å®šä¹‰æ¨¡å‹
å½“æˆ‘ä»¬åœ¨ 3.2èŠ‚ä¸­å®ç°çº¿æ€§å›å½’æ—¶ï¼Œæˆ‘ä»¬æ˜ç¡®å®šä¹‰äº†æ¨¡å‹å‚æ•°å˜é‡ï¼Œå¹¶ç¼–å†™äº†è®¡ç®—çš„ä»£ç ï¼Œè¿™æ ·é€šè¿‡åŸºæœ¬çš„çº¿æ€§ä»£æ•°è¿ç®—å¾—åˆ°è¾“å‡ºã€‚ä½†æ˜¯ï¼Œå¦‚æœæ¨¡å‹å˜å¾—æ›´åŠ å¤æ‚ï¼Œè€Œä¸”å½“ä½ å‡ ä¹æ¯å¤©éƒ½éœ€è¦å®ç°æ¨¡å‹æ—¶ï¼Œä½ ä¼šæƒ³ç®€åŒ–è¿™ä¸ªè¿‡ç¨‹ã€‚è¿™ç§æƒ…å†µç±»ä¼¼äºä»å¤´å¼€å§‹ç¼–å†™è‡ªå·±çš„åšå®¢ã€‚åšä¸€ä¸¤æ¬¡æ˜¯æœ‰ç›Šçš„ã€æœ‰å¯å‘æ€§çš„ï¼Œä½†å¦‚æœæ¯æ¬¡ä½ æ¯éœ€è¦ä¸€ä¸ªåšå®¢å°±èŠ±ä¸€ä¸ªæœˆçš„æ—¶é—´é‡æ–°å‘æ˜è½®å­ï¼Œé‚£ä½ å°†æ˜¯ä¸€ä¸ªç³Ÿç³•çš„ç½‘é¡µå¼€å‘è€…ã€‚

å¯¹äºæ ‡å‡†æ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ¡†æ¶çš„é¢„å®šä¹‰å¥½çš„å±‚ã€‚è¿™ä½¿æˆ‘ä»¬åªéœ€å…³æ³¨ä½¿ç”¨å“ªäº›å±‚æ¥æ„é€ æ¨¡å‹ï¼Œè€Œä¸å¿…å…³æ³¨å±‚çš„å®ç°ç»†èŠ‚ã€‚æˆ‘ä»¬é¦–å…ˆå®šä¹‰ä¸€ä¸ªæ¨¡å‹å˜é‡netï¼Œå®ƒæ˜¯ä¸€ä¸ªSequentialç±»çš„å®ä¾‹ã€‚Sequentialç±»ä¸ºä¸²è”åœ¨ä¸€èµ·çš„å¤šä¸ªå±‚å®šä¹‰äº†ä¸€ä¸ªå®¹å™¨ã€‚å½“ç»™å®šè¾“å…¥æ•°æ®ï¼ŒSequentialå®ä¾‹å°†æ•°æ®ä¼ å…¥åˆ°ç¬¬ä¸€å±‚ï¼Œç„¶åå°†ç¬¬ä¸€å±‚çš„è¾“å‡ºä½œä¸ºç¬¬äºŒå±‚çš„è¾“å…¥ï¼Œä¾æ­¤ç±»æ¨ã€‚åœ¨ä¸‹é¢çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬çš„æ¨¡å‹åªåŒ…å«ä¸€ä¸ªå±‚ï¼Œå› æ­¤å®é™…ä¸Šä¸éœ€è¦Sequentialã€‚ä½†æ˜¯ç”±äºä»¥åå‡ ä¹æ‰€æœ‰çš„æ¨¡å‹éƒ½æ˜¯å¤šå±‚çš„ï¼Œåœ¨è¿™é‡Œä½¿ç”¨Sequentialä¼šè®©ä½ ç†Ÿæ‚‰æ ‡å‡†çš„æµæ°´çº¿ã€‚

å›é¡¾ å›¾3.1.2ä¸­çš„å•å±‚ç½‘ç»œæ¶æ„ï¼Œè¿™ä¸€å•å±‚è¢«ç§°ä¸ºå…¨è¿æ¥å±‚ï¼ˆfully-connected layerï¼‰ï¼Œå› ä¸ºå®ƒçš„æ¯ä¸€ä¸ªè¾“å…¥éƒ½é€šè¿‡çŸ©é˜µ-å‘é‡ä¹˜æ³•è¿æ¥åˆ°å®ƒçš„æ¯ä¸ªè¾“å‡ºã€‚

### torchç‰ˆ

åœ¨PyTorchä¸­ï¼Œå…¨è¿æ¥å±‚åœ¨Linearç±»ä¸­å®šä¹‰ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œæˆ‘ä»¬å°†ä¸¤ä¸ªå‚æ•°ä¼ é€’åˆ°nn.Linearä¸­ã€‚ç¬¬ä¸€ä¸ªæŒ‡å®šè¾“å…¥ç‰¹å¾å½¢çŠ¶ï¼Œå³2ï¼Œç¬¬äºŒä¸ªæŒ‡å®šè¾“å‡ºç‰¹å¾å½¢çŠ¶ï¼Œè¾“å‡ºç‰¹å¾å½¢çŠ¶ä¸ºå•ä¸ªæ ‡é‡ï¼Œå› æ­¤ä¸º1ã€‚


```python
# `nn` æ˜¯ç¥ç»ç½‘ç»œçš„ç¼©å†™
from torch import nn

torch_net = nn.Sequential(nn.Linear(2, 1))
```

### paddleç‰ˆ


```python
paddle_net = paddle.nn.Sequential(paddle.nn.Linear(in_features=2, out_features=1))
print(paddle_net)
```

## 3.3.4 åˆå§‹åŒ–æ¨¡å‹å‚æ•°
åœ¨ä½¿ç”¨netä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦åˆå§‹åŒ–æ¨¡å‹å‚æ•°ã€‚å¦‚åœ¨çº¿æ€§å›å½’æ¨¡å‹ä¸­çš„æƒé‡å’Œåç½®ã€‚ æ·±åº¦å­¦ä¹ æ¡†æ¶é€šå¸¸æœ‰é¢„å®šä¹‰çš„æ–¹æ³•æ¥åˆå§‹åŒ–å‚æ•°ã€‚ åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬æŒ‡å®šæ¯ä¸ªæƒé‡å‚æ•°åº”è¯¥ä»å‡å€¼ä¸º0ã€æ ‡å‡†å·®ä¸º0.01çš„æ­£æ€åˆ†å¸ƒä¸­éšæœºé‡‡æ ·ï¼Œåç½®å‚æ•°å°†åˆå§‹åŒ–ä¸ºé›¶ã€‚

### torchç‰ˆ

æ­£å¦‚æˆ‘ä»¬åœ¨æ„é€ nn.Linearæ—¶æŒ‡å®šè¾“å…¥å’Œè¾“å‡ºå°ºå¯¸ä¸€æ ·ã€‚ç°åœ¨æˆ‘ä»¬ç›´æ¥è®¿é—®å‚æ•°ä»¥è®¾å®šåˆå§‹å€¼ã€‚æˆ‘ä»¬é€šè¿‡net[0]é€‰æ‹©ç½‘ç»œä¸­çš„ç¬¬ä¸€ä¸ªå›¾å±‚ï¼Œç„¶åä½¿ç”¨weight.dataå’Œbias.dataæ–¹æ³•è®¿é—®å‚æ•°ã€‚ç„¶åä½¿ç”¨æ›¿æ¢æ–¹æ³•normal_å’Œfill_æ¥é‡å†™å‚æ•°å€¼ã€‚


```python
torch_net[0].weight.data.normal_(0, 0.01)
torch_net[0].bias.data.fill_(0)
```

### paddleç‰ˆ


```python
# å…ˆæ”¾ç€
# paddle_net[0].weight.data.normal_(0, 0.01)
# paddle_net[0].weight.data
# paddle_net[0].bias.data.fill_(0)
```

## 3.3.5 å®šä¹‰æŸå¤±å‡½æ•°
è®¡ç®—å‡æ–¹è¯¯å·®ä½¿ç”¨çš„æ˜¯MSELossç±»ï¼Œä¹Ÿç§°ä¸ºå¹³æ–¹ ğ¿2
 èŒƒæ•°ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå®ƒè¿”å›æ‰€æœ‰æ ·æœ¬æŸå¤±çš„å¹³å‡å€¼ã€‚

### torchç‰ˆ


```python
torch_loss = nn.MSELoss()
```

### paddleç‰ˆ


```python
paddle_loss = paddle.nn.MSELoss()
```

## 3.3.6 å®šä¹‰ä¼˜åŒ–ç®—æ³•

å°æ‰¹é‡éšæœºæ¢¯åº¦ä¸‹é™ç®—æ³•æ˜¯ä¸€ç§ä¼˜åŒ–ç¥ç»ç½‘ç»œçš„æ ‡å‡†å·¥å…·ï¼ŒPyTorchåœ¨optimæ¨¡å—ä¸­å®ç°äº†è¯¥ç®—æ³•çš„è®¸å¤šå˜ç§ã€‚å½“æˆ‘ä»¬å®ä¾‹åŒ–SGDå®ä¾‹æ—¶ï¼Œæˆ‘ä»¬è¦æŒ‡å®šä¼˜åŒ–çš„å‚æ•°ï¼ˆå¯é€šè¿‡net.parameters()ä»æˆ‘ä»¬çš„æ¨¡å‹ä¸­è·å¾—ï¼‰ä»¥åŠä¼˜åŒ–ç®—æ³•æ‰€éœ€çš„è¶…å‚æ•°å­—å…¸ã€‚å°æ‰¹é‡éšæœºæ¢¯åº¦ä¸‹é™åªéœ€è¦è®¾ç½®lrå€¼ï¼Œè¿™é‡Œè®¾ç½®ä¸º0.03ã€‚

### torchç‰ˆ


```python
torch_trainer = torch.optim.SGD(torch_net.parameters(), lr=0.03)
```

### paddleç‰ˆ


```python
paddle_trainer = paddle.optimizer.SGD(learning_rate=0.03, parameters=paddle_net.parameters())
```

## 3.3.7 è®­ç»ƒ

é€šè¿‡æ·±åº¦å­¦ä¹ æ¡†æ¶çš„é«˜çº§APIæ¥å®ç°æˆ‘ä»¬çš„æ¨¡å‹åªéœ€è¦ç›¸å¯¹è¾ƒå°‘çš„ä»£ç ã€‚ æˆ‘ä»¬ä¸å¿…å•ç‹¬åˆ†é…å‚æ•°ã€ä¸å¿…å®šä¹‰æˆ‘ä»¬çš„æŸå¤±å‡½æ•°ï¼Œä¹Ÿä¸å¿…æ‰‹åŠ¨å®ç°å°æ‰¹é‡éšæœºæ¢¯åº¦ä¸‹é™ã€‚ å½“æˆ‘ä»¬éœ€è¦æ›´å¤æ‚çš„æ¨¡å‹æ—¶ï¼Œé«˜çº§APIçš„ä¼˜åŠ¿å°†å¤§å¤§å¢åŠ ã€‚ å½“æˆ‘ä»¬æœ‰äº†æ‰€æœ‰çš„åŸºæœ¬ç»„ä»¶ï¼Œè®­ç»ƒè¿‡ç¨‹ä»£ç ä¸æˆ‘ä»¬ä»é›¶å¼€å§‹å®ç°æ—¶æ‰€åšçš„éå¸¸ç›¸ä¼¼ã€‚

å›é¡¾ä¸€ä¸‹ï¼šåœ¨æ¯ä¸ªè¿­ä»£å‘¨æœŸé‡Œï¼Œæˆ‘ä»¬å°†å®Œæ•´éå†ä¸€æ¬¡æ•°æ®é›†ï¼ˆtrain_dataï¼‰ï¼Œä¸åœåœ°ä»ä¸­è·å–ä¸€ä¸ªå°æ‰¹é‡çš„è¾“å…¥å’Œç›¸åº”çš„æ ‡ç­¾ã€‚å¯¹äºæ¯ä¸€ä¸ªå°æ‰¹é‡ï¼Œæˆ‘ä»¬ä¼šè¿›è¡Œä»¥ä¸‹æ­¥éª¤:
- é€šè¿‡è°ƒç”¨net(X)ç”Ÿæˆé¢„æµ‹å¹¶è®¡ç®—æŸå¤±lï¼ˆæ­£å‘ä¼ æ’­ï¼‰ã€‚
- é€šè¿‡è¿›è¡Œåå‘ä¼ æ’­æ¥è®¡ç®—æ¢¯åº¦ã€‚
- é€šè¿‡è°ƒç”¨ä¼˜åŒ–å™¨æ¥æ›´æ–°æ¨¡å‹å‚æ•°ã€‚

ä¸ºäº†æ›´å¥½çš„è¡¡é‡è®­ç»ƒæ•ˆæœï¼Œæˆ‘ä»¬è®¡ç®—æ¯ä¸ªè¿­ä»£å‘¨æœŸåçš„æŸå¤±ï¼Œå¹¶æ‰“å°å®ƒæ¥ç›‘æ§è®­ç»ƒè¿‡ç¨‹ã€‚

### torchç‰ˆ



```python
num_epochs = 3
for epoch in range(num_epochs):
    for X, y in torch_data_iter:
        l = torch_loss(torch_net(X) ,y)
        torch_trainer.zero_grad()
        l.backward()
        torch_trainer.step()
    l = torch_loss(torch_net(torch_features), torch_labels)
    print(f'epoch {epoch + 1}, loss {l:f}')
```

ä¸‹é¢æˆ‘ä»¬æ¯”è¾ƒç”Ÿæˆæ•°æ®é›†çš„çœŸå®å‚æ•°å’Œé€šè¿‡æœ‰é™æ•°æ®è®­ç»ƒè·å¾—çš„æ¨¡å‹å‚æ•°ã€‚ è¦è®¿é—®å‚æ•°ï¼Œæˆ‘ä»¬é¦–å…ˆä»netè®¿é—®æ‰€éœ€çš„å±‚ï¼Œç„¶åè¯»å–è¯¥å±‚çš„æƒé‡å’Œåç½®ã€‚ æ­£å¦‚åœ¨ä»é›¶å¼€å§‹å®ç°ä¸­ä¸€æ ·ï¼Œæˆ‘ä»¬ä¼°è®¡å¾—åˆ°çš„å‚æ•°ä¸ç”Ÿæˆæ•°æ®çš„çœŸå®å‚æ•°éå¸¸æ¥è¿‘ã€‚


```python
w = torch_net[0].weight.data
print('wçš„ä¼°è®¡è¯¯å·®ï¼š', torch_w - w.reshape(torch_w.shape))
b = net[0].bias.data
print('bçš„ä¼°è®¡è¯¯å·®ï¼š', torch_b - b)
```

### paddleç‰ˆ


```python
num_epochs = 3
for epoch in range(num_epochs):
    for X, y in paddle_data_iter:
        l = paddle_loss(paddle_net(X) ,y)
        paddle_trainer.zero_grad()
        l.backward()
        paddle_trainer.step()
    l = paddle_loss(paddle_net(paddle_features), paddle_labels)
    print(f'epoch {epoch + 1}, loss {l:f}')
# for epoch in range(num_epochs):
#   y_predict = paddle_net(paddle_features)
#   loss=paddle_loss(y_predict, paddle_labels)
#   loss.backward()
#   paddle_trainer .step()
#   paddle_trainer .clear_grad()
#   print(f'epoch {epoch + 1}, loss {loss:f}')
```
