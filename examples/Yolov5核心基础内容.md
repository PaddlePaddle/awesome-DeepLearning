Yolov5核心基础内容

Yolov5的结构和Yolov4很相似，但也有一些不同，还是分为输入端、Backbone、Neck、Prediction四个部分。

（1）输入端：Mosaic数据增强、自适应锚框计算

（2）Backbone：Focus结构，CSP结构

（3）Neck：FPN+PAN结构

（4）Prediction：GIOU_Loss

Yolov5s网络最小，速度最少，AP精度也最低。

但如果检测的以大目标为主，追求速度，倒也是个不错的选择。

其他的三种网络，在此基础上，不断加深加宽网络，AP精度也不断提升，但速度的消耗也在不断增加。

2.2.1 输入端

（1）Mosaic数据增强

Yolov5的输入端采用了和Yolov4一样的Mosaic数据增强的方式。

Mosaic数据增强提出的作者也是来自Yolov5团队的成员，不过，随机缩放、随机裁剪、随机排布的方式进行拼接，对于小目标的检测效果还是很不错的。

（2）自适应锚框计算

在Yolo算法中，针对不同的数据集，都会有初始设定长宽的锚框。

在网络训练中，网络在初始锚框的基础上输出预测框，进而和真实框groundtruth进行比对，计算两者差距，再反向更新，迭代网络参数。

因此初始锚框也是比较重要的一部分，比如Yolov5在Coco数据集上初始设定的锚框：

在Yolov3、Yolov4中，训练不同的数据集时，计算初始锚框的值是通过单独的程序运行的。但Yolov5中将此功能嵌入到代码中，每次训练时，自适应的计算不同训练集中的最佳锚框值。当然，如果觉得计算的锚框效果不是很好，也可以在代码中将自动计算锚框功能关闭。

控制的代码即train.py中上面一行代码，设置成False，每次训练时，不会自动计算。

（3）自适应图片缩放

在常用的目标检测算法中，不同的图片长宽都不相同，因此常用的方式是将原始图片统一缩放到一个标准尺寸，再送入检测网络中。

比如Yolo算法中常用416×416，608×608等尺寸，比如对下面800\*600的图像进行变换。

但Yolov5代码中对此进行了改进，也是Yolov5推理速度能够很快的一个不错的trick。作者认为，在项目实际使用时，很多图片的长宽比不同。

因此缩放填充后，两端的黑边大小都不同，而如果填充的比较多，则存在信息冗余，影响推理速度。因此在Yolov5代码中datasets.py的letterbox函数中进行了修改，对原始图像自适应的添加最少的黑边。

图像高度上两端的黑边变少了，在推理时，计算量也会减少，即目标检测速度会得到提升。

第一步：计算缩放比例

原始缩放尺寸是416×416，都除以原始图像的尺寸后，可以得到0.52，和0.69两个缩放系数，选择小的缩放系数0.52。

第二步：计算缩放后的尺寸

原始图片的长宽都乘以最小的缩放系数0.52，宽变成了416，而高变成了312。

第三步：计算黑边填充数值

将416-312=104，得到原本需要填充的高度。再采用numpy中np.mod取余数的方式，得到8个像素，再除以2，即得到图片高度两端需要填充的数值。

2.2.2 Backbone

（1）Focus结构

Focus结构，在Yolov3&Yolov4中并没有这个结构，其中比较关键是切片操作。

以Yolov5s的结构为例，原始608×608×3的图像输入Focus结构，采用切片操作，先变成304×304×12的特征图，再经过一次32个卷积核的卷积操作，最终变成304×304×32的特征图。需要注意的是：Yolov5s的Focus结构最后使用了32个卷积核，而其他三种结构，使用的数量有所增加，先注意下，后面会讲解到四种结构的不同点。

（2）CSP结构

Yolov4网络结构中，借鉴了CSPNet的设计思路，在主干网络中设计了CSP结构。

Yolov5与Yolov4不同点在于，Yolov4中只有主干网络使用了CSP结构，而Yolov5中设计了两种CSP结构，以Yolov5s网络为例，以CSP1_X结构应用于Backbone主干网络，另一种CSP2_X结构则应用于Neck中。

2.2.3 Neck

Yolov5现在的Neck和Yolov4中一样，都采用FPN+PAN的结构，但在Yolov5刚出来时，只使用了FPN结构，后面才增加了PAN结构，此外网络中其他部分也进行了调整。

但如上面CSPNet中讲到，Yolov5和Yolov4的不同点在于，Yolov4的Neck中，采用的都是普通的卷积操作。

而Yolov5的Neck结构中，采用借鉴CSPNet设计的CSP2结构，加强网络特征融合的能力。

2.2.4 输出端

（1）Bounding box损失函数

Yolov5中采用其中的GIOU_Loss做Bounding
box的损失函数。而Yolov4中采用CIOU_Loss作为目标Bounding box的损失函数。

（2）nms非极大值抑制

在目标检测的后处理过程中，针对很多目标框的筛选，通常需要nms操作。

Yolov4在DIOU_Loss的基础上采用DIOU_nms的方式，而Yolov5中仍然采用加权nms的方式。可以看出，采用DIOU_nms，下方中间箭头的黄色部分，原本被遮挡的摩托车也可以检出。

2.3 Yolov5四种网络结构的不同点

Yolov5代码中的四种网络，和之前的Yolov3，Yolov4中的cfg文件不同，都是以yaml的形式来呈现。而且四个文件的内容基本上都是一样的，只有最上方的depth_multiple和width_multiple两个参数不同，很多同学看的一脸懵逼，不知道只通过两个参数是如何控制四种结构的？

2.3.1 四种结构的参数

（1）Yolov5s.yaml

（2）Yolov5m.yaml

（3）Yolov5l.yaml

（4）Yolov5x.yaml

四种结构就是通过上面的两个参数，来进行控制网络的深度和宽度。其中depth_multiple控制网络的深度，width_multiple控制网络的宽度。

2.3.2 Yolov5网络结构

四种结构的yaml文件中，下方的网络架构代码都是一样的。

为了便于讲解，大白将其中的Backbon部分提取出来，讲解如何控制网络的宽度和深度，yaml文件中的Head部分也是同样的原理。

在对网络结构进行解析时，yolo.py中下方的这一行代码将四种结构的depth_multiple，width_multiple提取出，赋值给gd，gw。后面主要对这gd，gw这两个参数进行讲解。

下面再细致的剖析下，看是如何控制每种结构，深度和宽度的。

2.3.3 Yolov5四种网络的深度

（1）不同网络的深度

需要注意的是，四种网络结构中每个CSP结构的深度都是不同的。

a. 以Yolov5s为例，第一个CSP1中，使用了1个残差组件，因此是CSP1_1。

而在Yolov5m中，则增加了网络的深度，在第一个CSP1中，使用了2个残差组件，因此是CSP1_2。

而Yolov5l中，同样的位置，则使用了3个残差组件，Yolov5x中，使用了4个残差组件。其余的第二个CSP1和第三个CSP1也是同样的原理。

b. 在第二种CSP2结构中也是同样的方式，以第一个CSP2结构为例。

Yolov5s组件中使用了2×X=2×1=2个卷积，因为Ｘ=1，所以使用了1组卷积，因此是CSP2_1。

而Yolov5m中使用了2组，Yolov5l中使用了3组，Yolov5x中使用了4组。其他的四个CSP2结构，也是同理。

Yolov5中，网络的不断加深，也在不断增加网络特征提取和特征融合的能力。

（2）控制深度的代码

控制四种网络结构的核心代码是yolo.py中下面的代码，存在两个变量，n和gd。

（3）验证控制深度的有效性

a. yolov5s.yaml

其中depth_multiple=0.33，即gd=0.33，而n则由上面红色框中的信息获得。

以上面网络框图中的第一个CSP1为例，即上面的第一个红色框。n等于第二个数值3。

而gd=0.33，带入（2）中的计算代码，结果n=1。因此第一个CSP1结构内只有1个残差组件，即CSP1_1。

第二个CSP1结构中，n等于第二个数值9，而gd=0.33，带入（2）中计算，结果n=3，因此第二个CSP1结构中有3个残差组件，即CSP1_3。

第三个CSP1结构也是同理，这里不多说。

b. yolov5l.xml

其中depth_multiple=1，即gd=1

和上面的计算方式相同，第一个CSP1结构中，n=3，带入代码中，结果n=3，因此为CSP1_3。

下面第二个CSP1结构和第三个CSP1结构都是同样的原理。

2.3.4 Yolov5四种网络的宽度

（1）不同网络的宽度

如上图表格中所示，四种Yolov5结构在不同阶段的卷积核的数量都是不一样的。

因此也直接影响卷积后特征图的第三维度，即厚度，大白这里表示为网络的宽度。

a.
以Yolov5s结构为例，第一个Focus结构中，最后卷积操作时，卷积核的数量是32个，因此经过Focus结构，特征图的大小变成304×304×32。

而Yolov5m的Focus结构中的卷积操作使用了48个卷积核，因此Focus结构后的特征图变成304×304×48。Yolov5l，Yolov5x也是同样的原理。

b.
第二个卷积操作时，Yolov5s使用了64个卷积核，因此得到的特征图是152×152×64。而Yolov5m使用96个特征图，因此得到的特征图是152×152×96。Yolov5l，Yolov5x也是同理。

c. 后面三个卷积下采样操作也是同样的原理，这样大白不过多讲解。

四种不同结构的卷积核的数量不同，这也直接影响网络中比如CSP1结构，CSP2等结构，以及各个普通卷积，卷积操作时的卷积核数量也同步在调整，影响整体网络的计算量。

大家最好可以将结构图和前面第一部分四个网络的特征图链接，对应查看，思路会更加清晰。

当然卷积核的数量越多，特征图的厚度，即宽度越宽，网络提取特征的学习能力也越强。

（2）控制宽度的代码

在Yolov5的代码中，控制宽度的核心代码是yolo.py文件里面的这一行：

它所调用的子函数make_divisible的功能是：

（3）验证控制宽度的有效性

我们还是选择最小的Yolov5s和中间的Yolov5l两个网络结构，将width_multiple系数带入，看是否正确。

a. yolov5s.yaml

其中width_multiple=0.5，即gw=0.5。

以第一个卷积下采样为例，即Focus结构中下面的卷积操作。

按照上面Backbone的信息，我们知道Focus中，标准的c2=64，而gw=0.5，代入（2）中的计算公式，最后的结果=32。即Yolov5s的Focus结构中，卷积下采样操作的卷积核数量为32个。

再计算后面的第二个卷积下采样操作，标准c2的值=128，gw=0.5，代入（2）中公式，最后的结果=64，也是正确的。

b. yolov5l.yaml

其中width_multiple=1，即gw=1，而标准的c2=64，代入上面（2）的计算公式中，可以得到Yolov5l的Focus结构中，卷积下采样操作的卷积核的数量为64个，而第二个卷积下采样的卷积核数量是128个。

另外的三个卷积下采样操作，以及Yolov5m，Yolov5x结构也是同样的计算方式，
